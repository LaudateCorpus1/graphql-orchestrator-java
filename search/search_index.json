{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphQL Orchestrator \u00b6 Introduction \u00b6 Unlike REST, GraphQL follows a single endpoint model wherein, the client is expected to call one endpoint to get all its data. A large organization typically consists of numerous microservices that are owned by different teams. This leads to a need for a GraphQL orchestrator that provides a single graphql endpoint orchestrating data across multiple graphql providers. GraphQL Orchestrator is a library that exposes data from various data providers using a single unified GraphQL schema. It aggregates and combines the schemas from these data providers and orchestrates the incoming graphql queries to the appropriate services. It uses the graphql-java library as the runtime execution engine on the unified schema. It provides the following features Recursive schema stitching Parallel network calls to Data Providers Batching queries \u00a9 Copyright 2021 Intuit Inc.","title":"Home"},{"location":"#graphql-orchestrator","text":"","title":"GraphQL Orchestrator"},{"location":"#introduction","text":"Unlike REST, GraphQL follows a single endpoint model wherein, the client is expected to call one endpoint to get all its data. A large organization typically consists of numerous microservices that are owned by different teams. This leads to a need for a GraphQL orchestrator that provides a single graphql endpoint orchestrating data across multiple graphql providers. GraphQL Orchestrator is a library that exposes data from various data providers using a single unified GraphQL schema. It aggregates and combines the schemas from these data providers and orchestrates the incoming graphql queries to the appropriate services. It uses the graphql-java library as the runtime execution engine on the unified schema. It provides the following features Recursive schema stitching Parallel network calls to Data Providers Batching queries \u00a9 Copyright 2021 Intuit Inc.","title":"Introduction"},{"location":"key-concepts/algorithm/","text":"High Level Algorithm \u00b6 The orchestrator merges the schema using a very simple merging algorithm. It uses Xtext to parse the schema files into an Abstract Syntax Tree(AST) representation. The Xtext internally uses Antlr, but provides some additional features like cross-referencing, custom validations, etc. that has been very helpful to operate on the graph. The Algorithm consists of 3 phases - Pre-Merge Transformers \u00b6 This phase consists of performing a set of transformations to the individual providers schemas. Such transformations enrich the xtext AST. Some examples include attaching namespace to the description of all the types of the provider, marking if the schema contains union or interfaces etc. The top level fields inside Query type are also marked with appropriate DataFetcher context to prepare the graphql-java code registry. Merging \u00b6 The individual schemas are merged to form a single unified schema using a recursive strategy . The output is a Xtext AST that can further be enriched by applying post merge transformations. During this phase, the graphql-java code registry is also modified as per the strategy. Post-Merge Transformers \u00b6 The post merge transformers applies to the final unified schema. One such transformation converts the Xtext AST to an executable GraphQLSchema which can be used to execute GraphQL queries on the orchestrator. \u00a9 Copyright 2021 Intuit Inc.","title":"High Level Algorithm"},{"location":"key-concepts/algorithm/#high-level-algorithm","text":"The orchestrator merges the schema using a very simple merging algorithm. It uses Xtext to parse the schema files into an Abstract Syntax Tree(AST) representation. The Xtext internally uses Antlr, but provides some additional features like cross-referencing, custom validations, etc. that has been very helpful to operate on the graph. The Algorithm consists of 3 phases -","title":"High Level Algorithm"},{"location":"key-concepts/algorithm/#pre-merge-transformers","text":"This phase consists of performing a set of transformations to the individual providers schemas. Such transformations enrich the xtext AST. Some examples include attaching namespace to the description of all the types of the provider, marking if the schema contains union or interfaces etc. The top level fields inside Query type are also marked with appropriate DataFetcher context to prepare the graphql-java code registry.","title":"Pre-Merge Transformers"},{"location":"key-concepts/algorithm/#merging","text":"The individual schemas are merged to form a single unified schema using a recursive strategy . The output is a Xtext AST that can further be enriched by applying post merge transformations. During this phase, the graphql-java code registry is also modified as per the strategy.","title":"Merging"},{"location":"key-concepts/algorithm/#post-merge-transformers","text":"The post merge transformers applies to the final unified schema. One such transformation converts the Xtext AST to an executable GraphQLSchema which can be used to execute GraphQL queries on the orchestrator. \u00a9 Copyright 2021 Intuit Inc.","title":"Post-Merge Transformers"},{"location":"key-concepts/graphql-query-execution/","text":"GraphQL Query Execution \u00b6 GraphQL Orchestrator uses the graphql-java library for query execution at runtime. In this section, we will discuss how the Orchestrator breaks up an incoming query into multiple sub-queries to be sent to their respective service providers. Deconstructing your query | Rebuilding the response \u00b6 GraphQL Orchestrator partitions a query into sub-queries, so that downstream services only get queries for the schema that they operate on. Given a scenario, imagine that query.person/spouse.firstName are served by NameService, and query.person/spouse.address.city is served by Address. Here is a query that requests for both pieces of information: query { person { firstName address { city } } spouse { firstName address { city } } } GraphQL Orchestrator will split this query into two subqueries and call the appropriate providers in parallel: query { person { firstname } spouse { firstname } } query { person { address { ciy } } spouse { address { ciy } } } Note that GraphQL Orchestrator will preserve the query hierarchy no matter how deep it must traverse to split the query. After retrieving the individual responses from separate services, the orchestrator combines both GraphQL errors and data into a single response for the client. Batching queries \u00b6 Even though the firstName field is at a different level for person and spouse, they belong to the same provider. The GraphQL Orchestrator will make sure that the fields that belong to the NameService provider as batched together before calling the provider. In simple words, the GraphQL Orchestrator will make sure that the downstream provider is only called once per request, regardless of the schema hierarchy. \u00a9 Copyright 2021 Intuit Inc.","title":"GraphQL Query Execution"},{"location":"key-concepts/graphql-query-execution/#graphql-query-execution","text":"GraphQL Orchestrator uses the graphql-java library for query execution at runtime. In this section, we will discuss how the Orchestrator breaks up an incoming query into multiple sub-queries to be sent to their respective service providers.","title":"GraphQL Query Execution"},{"location":"key-concepts/graphql-query-execution/#deconstructing-your-query-rebuilding-the-response","text":"GraphQL Orchestrator partitions a query into sub-queries, so that downstream services only get queries for the schema that they operate on. Given a scenario, imagine that query.person/spouse.firstName are served by NameService, and query.person/spouse.address.city is served by Address. Here is a query that requests for both pieces of information: query { person { firstName address { city } } spouse { firstName address { city } } } GraphQL Orchestrator will split this query into two subqueries and call the appropriate providers in parallel: query { person { firstname } spouse { firstname } } query { person { address { ciy } } spouse { address { ciy } } } Note that GraphQL Orchestrator will preserve the query hierarchy no matter how deep it must traverse to split the query. After retrieving the individual responses from separate services, the orchestrator combines both GraphQL errors and data into a single response for the client.","title":"Deconstructing your query | Rebuilding the response"},{"location":"key-concepts/graphql-query-execution/#batching-queries","text":"Even though the firstName field is at a different level for person and spouse, they belong to the same provider. The GraphQL Orchestrator will make sure that the fields that belong to the NameService provider as batched together before calling the provider. In simple words, the GraphQL Orchestrator will make sure that the downstream provider is only called once per request, regardless of the schema hierarchy. \u00a9 Copyright 2021 Intuit Inc.","title":"Batching queries"},{"location":"key-concepts/interface-union-types/","text":"Interface or Union Types \u00b6 An interface is an abstract type that includes a certain set of fields that a type must include. interface Pet { id: ID! } type Dog implements Pet { id: ID! price: Int } type Cat implements Pet { id: ID! livesLeft: Int! } Union types are very similar to interfaces, but they don't get to specify any common fields between the types. type Dog { name: String price: Int } type Cat { id: ID livesLeft: Int! } union Pet = Dog | Cat Learn more on interface and union, Problem \u00b6 When the provider has a field that returns a Pet(union or interface) type in the schema, the result can be of type Dog or Cat. The graphql provider serving the Pet type needs to implement a type-resolver to resolve Pet to either Cat or Dog at query execution time. When the graphql provider registers with the orchestrator, the orchestrator gets the types Pet, Cat, and Dog, but does not have any information about the business logic of the type resolver. Solution \u00b6 The orchestrator handles such fields by implementing a generic type resolver using the introspection field __typename . It transforms the incoming query by adding the field __typename so that the provider returns the type name. Let's take an example query made by the client to the orchestrator for the interface Pet query { allPets { id ... on Dog { price } ... on Cat { livesLeft } } } The query that the orchestrator makes to the Pet provider looks like query { allPets { __typename id ... on Dog { price } ... on Cat { livesLeft } } } \u00a9 Copyright 2021 Intuit Inc.","title":"Interfaces and Unions"},{"location":"key-concepts/interface-union-types/#interface-or-union-types","text":"An interface is an abstract type that includes a certain set of fields that a type must include. interface Pet { id: ID! } type Dog implements Pet { id: ID! price: Int } type Cat implements Pet { id: ID! livesLeft: Int! } Union types are very similar to interfaces, but they don't get to specify any common fields between the types. type Dog { name: String price: Int } type Cat { id: ID livesLeft: Int! } union Pet = Dog | Cat Learn more on interface and union,","title":"Interface or Union Types"},{"location":"key-concepts/interface-union-types/#problem","text":"When the provider has a field that returns a Pet(union or interface) type in the schema, the result can be of type Dog or Cat. The graphql provider serving the Pet type needs to implement a type-resolver to resolve Pet to either Cat or Dog at query execution time. When the graphql provider registers with the orchestrator, the orchestrator gets the types Pet, Cat, and Dog, but does not have any information about the business logic of the type resolver.","title":"Problem"},{"location":"key-concepts/interface-union-types/#solution","text":"The orchestrator handles such fields by implementing a generic type resolver using the introspection field __typename . It transforms the incoming query by adding the field __typename so that the provider returns the type name. Let's take an example query made by the client to the orchestrator for the interface Pet query { allPets { id ... on Dog { price } ... on Cat { livesLeft } } } The query that the orchestrator makes to the Pet provider looks like query { allPets { __typename id ... on Dog { price } ... on Cat { livesLeft } } } \u00a9 Copyright 2021 Intuit Inc.","title":"Solution"},{"location":"key-concepts/merging-types/","text":"Merging types \u00b6 GraphQL Orchestrator combines schema from multiple data providers into a unified schema at runtime. When a data consumer makes a graphql query to the orchestrator, the orchestrator is able to split the query to appropriate providers, execute the query and combine the results accurately. The orchestrator performs recursive merging of types using the stitching algorithm. Take an example of two providers: Pet Service type Query { allPets: [PetType] } type PetType{ ... } User Service type Query { user(id: ID!): UserType! } type UserType{ ... } The orchestrator starts the stitching process at the very top-level i.e the Query type. It merges the fields of provider 1 with provider 2 and creates the final Query type. type Query { allPets: [PetType] user(id: ID!): UserType! } type UserType { ... } type PetType { ... } Recursive merging \u00b6 Nested types are also merged according to the strategy above. type Query { person: PersonType } type PersonType { firstName: String lastName: String } type Query { person: PersonType } type PersonType { address: AddressType } type AddressType {...} type Query { person: PersonType } type PersonType { firstName: String lastName: String address: AddressType # address type is merged } type AddressType {...} Directives and Arguments \u00b6 The recursive merging strategy does not apply if the nested type being merged has an arguments or directives. The strategy's purpose is to have some structure to the final unified schema so that it is easy to explore. \u00a9 Copyright 2021 Intuit Inc.","title":"Merging types"},{"location":"key-concepts/merging-types/#merging-types","text":"GraphQL Orchestrator combines schema from multiple data providers into a unified schema at runtime. When a data consumer makes a graphql query to the orchestrator, the orchestrator is able to split the query to appropriate providers, execute the query and combine the results accurately. The orchestrator performs recursive merging of types using the stitching algorithm. Take an example of two providers: Pet Service type Query { allPets: [PetType] } type PetType{ ... } User Service type Query { user(id: ID!): UserType! } type UserType{ ... } The orchestrator starts the stitching process at the very top-level i.e the Query type. It merges the fields of provider 1 with provider 2 and creates the final Query type. type Query { allPets: [PetType] user(id: ID!): UserType! } type UserType { ... } type PetType { ... }","title":"Merging types"},{"location":"key-concepts/merging-types/#recursive-merging","text":"Nested types are also merged according to the strategy above. type Query { person: PersonType } type PersonType { firstName: String lastName: String } type Query { person: PersonType } type PersonType { address: AddressType } type AddressType {...} type Query { person: PersonType } type PersonType { firstName: String lastName: String address: AddressType # address type is merged } type AddressType {...}","title":"Recursive merging"},{"location":"key-concepts/merging-types/#directives-and-arguments","text":"The recursive merging strategy does not apply if the nested type being merged has an arguments or directives. The strategy's purpose is to have some structure to the final unified schema so that it is easy to explore. \u00a9 Copyright 2021 Intuit Inc.","title":"Directives and Arguments"},{"location":"usage/getting_started/","text":"Getting Started \u00b6 Pre-requisites \u00b6 Java 8 Dependency \u00b6 <dependency> <groupId> com.intuit.graphql </groupId> <artifactId> graphql-orchestrator-java </artifactId> <version> ${graphql.orchestrator.version} </version> </dependency> Usage in code \u00b6 Implement the ServiceProvider interface class TemplateServiceProvider implements ServiceProvider { public static final String TEMPLATE = \"type Query { nested: Nested } type Nested { %s: String}\" ; private String field ; public TemplateServiceProvider ( String field ) { this . field = field ; } @Override public String getNameSpace () { return field ; } @Override public Map < String , String > sdlFiles () { return ImmutableMap . of ( field + \".graphqls\" , String . format ( TEMPLATE , field )); } @Override public CompletableFuture < Map < String , Object >> query ( final ExecutionInput executionInput , final GraphQLContext context ) { //{'data':{'nested':{'%s':'%s'}}}\" Map < String , Object > data = ImmutableMap . of ( \"data\" , ImmutableMap . of ( \"nested\" , ImmutableMap . of ( field , field ))); return CompletableFuture . completedFuture ( data ); } } Create an instance of Orchestrator and execute the query as below. // create a runtimeGraph by stitching service providers RuntimeGraph runtimeGraph = SchemaStitcher . newBuilder () . service ( new TemplateServiceProvider ( \"foo\" )) . service ( new TemplateServiceProvider ( \"bar\" )) . build () . stitchGraph (); // pass the runtime graph to GraphQLOrchestrator GraphQLOrchestrator graphQLOrchestrator = GraphQLOrchestrator . newOrchestrator () . runtimeGraph ( runtimeGraph ). build (); //Execute the query CompletableFuture < ExecutionResult > execute = graphQLOrchestrator . execute ( ExecutionInput . newExecutionInput (). query ( \"query {nested {foo bar}}\" ). build ()); ExecutionResult executionResult = execute . get (); System . out . println ( executionResult . getData (). toString ()); // Output: {nested={foo=foo, bar=bar}} \u00a9 Copyright 2021 Intuit Inc.","title":"Getting Started"},{"location":"usage/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"usage/getting_started/#pre-requisites","text":"Java 8","title":"Pre-requisites"},{"location":"usage/getting_started/#dependency","text":"<dependency> <groupId> com.intuit.graphql </groupId> <artifactId> graphql-orchestrator-java </artifactId> <version> ${graphql.orchestrator.version} </version> </dependency>","title":"Dependency"},{"location":"usage/getting_started/#usage-in-code","text":"Implement the ServiceProvider interface class TemplateServiceProvider implements ServiceProvider { public static final String TEMPLATE = \"type Query { nested: Nested } type Nested { %s: String}\" ; private String field ; public TemplateServiceProvider ( String field ) { this . field = field ; } @Override public String getNameSpace () { return field ; } @Override public Map < String , String > sdlFiles () { return ImmutableMap . of ( field + \".graphqls\" , String . format ( TEMPLATE , field )); } @Override public CompletableFuture < Map < String , Object >> query ( final ExecutionInput executionInput , final GraphQLContext context ) { //{'data':{'nested':{'%s':'%s'}}}\" Map < String , Object > data = ImmutableMap . of ( \"data\" , ImmutableMap . of ( \"nested\" , ImmutableMap . of ( field , field ))); return CompletableFuture . completedFuture ( data ); } } Create an instance of Orchestrator and execute the query as below. // create a runtimeGraph by stitching service providers RuntimeGraph runtimeGraph = SchemaStitcher . newBuilder () . service ( new TemplateServiceProvider ( \"foo\" )) . service ( new TemplateServiceProvider ( \"bar\" )) . build () . stitchGraph (); // pass the runtime graph to GraphQLOrchestrator GraphQLOrchestrator graphQLOrchestrator = GraphQLOrchestrator . newOrchestrator () . runtimeGraph ( runtimeGraph ). build (); //Execute the query CompletableFuture < ExecutionResult > execute = graphQLOrchestrator . execute ( ExecutionInput . newExecutionInput (). query ( \"query {nested {foo bar}}\" ). build ()); ExecutionResult executionResult = execute . get (); System . out . println ( executionResult . getData (). toString ()); // Output: {nested={foo=foo, bar=bar}} \u00a9 Copyright 2021 Intuit Inc.","title":"Usage in code"}]}